---
title: "Assignment 2"
author: "Marine Courtin"
date: "9 octobre 2017"
output: html_document
---


## Exercise 1. Writing R functions


#### Question a.

+ __Loading functions__

    This chunk allows us to load functions that we've written in a separate R file :

```{r}
source("functions.R")
```

+ __Test on the existence of a column__

    It is rather easy to test whether a column exists. First we attribute the value returned by the column of the data frame. Then, we test `is.null(value)`. The boolean returned is True when the column does not exist and False when it does. It's also possible to test for the absence of the column using the __!__ operator.

+ __Test on the type of value of a vector__

    We can test the type of the data contained in our vector. Using `is.numeric(vector)` will return True if all values in our vector are numeric. As a reminder, elements of R vectors must be of the same type. If we do not respect this condition when creating the vector - for example declaring `vec <- c('mot`, 5)` - R automatically chooses a datatype in our place (here 5 would be converted to string).


Here's what we get when we apply the function : 

```{r}
print(sum_column(iris, "Sepal.Length"))
print(sum_column(iris, "Species"))
print(sum_column(warpbreaks, "breaks"))
```


#### Question b. 

+ __Boucler sur les valeurs d'un vecteur__

In order to add up the values of our vector, we loop on the elements and iteratively add their value to a variable. We first need to find out the number of elements using `length(vector)`. Then we create a loop which respects the `for (condition) {do}` construction. Our condition specifies the possibles values of the element's indexes : from 1 up to n, if we have n elements in our vector. We simply add the i*th* element of our vector to the total sum each time.


```{r}
print(my_sum(iris$Sepal.Length))
print(my_sum(iris$Species))
print(my_sum(warpbreaks$breaks))
```

#### Question c.

+ __Testing a combination of conditions__

This time, we want to use our `my_sum()` function inside another function `sum_divided_by()`. We give it two arguments : a vector of number x, and a number k by which we'll divide x. We initialize a NULL value to return in case our arguments do not respect these conditions. 
    
Here's the result :

```{r}
print(sum_divided_by(iris$Sepal.Length, 12))
print(sum_divided_by(iris$Species, 22))
print(sum_divided_by(iris$Sepal.Length, "Not numeric"))
print(sum_divided_by(warpbreaks$breaks, -12))
```

#### Question d.

+ __Calculating the mean of a vector__

We want to write a function which will calculate the mean of a vector. In order to do that, we can use the `sum_divided_by()` function we've juste created, and simply provide the length of our vector as the k argument.

We do not need to initialize the result value as NULL in this new function, as it is already part of the output produced by `sum_divided_by()`. If x is not a vector of number, `sum_divided_by()` will return NULL.

```{r}
print(my_mean(iris$Sepal.Length))
print(my_mean(iris$Species))
print(my_mean(warpbreaks$breaks))
```


## Exercise 2. Working with ggplot


#### Question a.

+ __Creating violin plots__

We want to write a function that will create violin plots. The function takes 3 arguments, the dataframe and the name of our column containing the dependant variable (y axis), and the name of our column containing the grouping variable (x axis).

Inside the function we use the `ggplot2::ggplot()` function to create the ggplot object, then we use `ggplot2::aes_string`to define the aesthetic mappings. According to [this page on ggplot2.tidyverse.org](http://ggplot2.tidyverse.org/index.html) : "Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms."

To create the violin plot we only need to add `ggplot2::geom_violin()` to our ggplot object. Here's the violin plot we created :

```{r}
print(grouped_violin_plot(iris, "Sepal.Length", "Species"))
```

#### Question b.

+ __Changing the color scheme and title of a plot__

There are many color palettes already available which facilitate the reading of plots. I used [colorbrewer 2.0](http://colorbrewer2.org/#) which is originally desgined for color coding cartographies to select my palette. The website is really useful as it provides the following options : 

+ number of data classes
+ nature of the data
+ colorblind safe feature -> when using colors to add extra dimensions to plots it is best to use color palettes that can be decoded by people with color vision deficiencies. A few references on this topic can be found [here](http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette) and [there](). 

```{r}
p <- grouped_violin_plot(iris, "Sepal.Length", "Species")
# We specify the color palette we want to use
p <- p + ggplot2::scale_fill_brewer(palette="Dark2")
# We add a title to our plot
p <- p + ggplot2::labs(title="Iris data")
print(p)
```


## Exercise 3. Permutation tests

#### Question a.

+ __Calculating median differences between two subgroups__

We're computing the difference in terms of sepal width medians for irises, depending on their species. We observe that versicolor and virginica irises have different sepal width medians.

```{r}
# Mesuring the difference in sepal width median for versicolor vs virginica irises
difference_in_medians(iris, "Sepal.Width", "Species", "versicolor", "virginica")
# We can hope that there is no difference in the median between 2 identical groups
difference_in_medians(iris, "Sepal.Width", "Species", "virginica", "virginica")
```

Comment : using `d_1$var` in my function instead of `d_1[[var]]` did not work. This is something that has been commented on at the beginning of this assignment, but I have not yet found why both can't be used interchangably.

#### Question b.

+ __Randomizing the order of a column to create permutation tests__

A brief summary of what our function does : d[[var]] contains our species for each dataline. We attribute a new value to it : its randomized content (i.e each dataline of the columns is attributed one of the species tags present in the original d[[var]]). This will result in a new dataframe, where we can observe what our data would look like if there was no systematic pattern between species and other variables such as sepal width.

```{r}
iris$Sepal.Width[1:10]
if(!exists(".Random.seed")) set.seed(NULL)
previous_seed <- .Random.seed
set.seed(1)
randomize(iris, "Sepal.Width")$Sepal.Width[1:10]
randomize(iris, "Species")$Species[1:10]
randomize(iris, "Species")$Sepal.Width[1:10]
set.seed(previous_seed)
```

Comment :  As it's been stated in the assignment, using a function to randomize the contents of a column inside the table does not affect our original data wich remains in its original state.